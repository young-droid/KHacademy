/* SELECT (DML 또는 DQL) : 조회
 * 
 * - 데이터를 조회(SELECT)하면 조건에 맞는 행들이 조회됨
 * -> 조회된 결과 행의 집합 == RESULT SET (결과 집합)
 * 
 * - RESULT SET은 0행 이상이 포함될 수 있다. 
 * -> 조회 조건에 맞는 행이 없을 수도 있기 때문에 0행도 포함됨
 * 
 * */

-- EMPLOYEE 테이블에서 모든 사원의 정보 조회
-- '*' : ALL, 모든, 전부
SELECT * FROM EMPLOYEE;

-- SELECT 컬럼명 FROM 테이블
-- EMPLOYEE 테이블에서 모든 사원의 이름만 조회
SELECT EMP_NAME FROM EMPLOYEE;

-- 테이블에서 모든 사원의 사번, 이름, 이메일, 급여 조회
SELECT EMP_ID, EMP_NAME, EMAIL, SALARY FROM EMPLOYEE;

-- DEPARTMENT 테이블에 있는 모든 행 조회
SELECT * FROM DEPARTMENT; 


----------------------------------------------------------------

-- <컬럼 값 산술 연산>
-- 컬럼 값 : 테이블의 한 칸(== 한 셀)에 적용된 값(data)

-- SELECT문 작성 시 컬럼명에 산술 연산을 작성하면
-- 조회되는 결과 컬럼 값에 산술 연산이 반영된다. 

-- EMPLOYEE 테이블에서 모든 사원의 사번, 이름, 급여, 급여 + 100만을 조회
SELECT EMP_ID, EMP_NAME, SALARY, SALARY + 1000000 SALARY_SUM
FROM EMPLOYEE;

SELECT EMP_NAME NAME, SALARY, SALARY*12 SALARY_YEARLY 
FROM EMPLOYEE e;

--------------------------------------------

-- ** <오늘 날짜 조회> **
SELECT SYSDATE FROM DUAL;

-- SYSDATE 	: 시스템 상의 현재 날짜
-- DUAL (DUmmy tAbLe): 더미 테이블(임시 테이블, 단순 조회 테이블)

-- * DB는 날짜 데이터의 연산(+,-)이 가능하다 (일 단위) *

SELECT SYSDATE, SYSDATE +1, SYSDATE -1 FROM DUAL;

-- EMPLOYEE 테이블에서 이름, 입사일, 오늘까지 근무한 날짜 조회
SELECT EMP_NAME, HIRE_DATE, (SYSDATE-HIRE_DATE) FROM EMPLOYEE e ;

------------------------------------------------------

-- <컬럼 별칭 지정>

-- SELECT 조회 결과의 집합인 RESULT SET에 컬럼명을 지정

/* 1) 컬럼명 AS 별칭	: 띄어쓰기X, 특수문자X, 문자O
 * 2) 컬럼명 별칭		: 1)번에서 AS만 생략한 것
 * 
 * 3) 컬럼명 AS "별칭"	: 띄어쓰기O, 특수문자O, 문자O
 * 4) 컬럼명 "별칭" 	: 3)번에서 AS만 생략한 것
 * */

-- EMPLOYEE 테이블에서
-- 사번, 이름, 급여(원), 근무 일수를 모두 조회
SELECT 	EMP_ID AS 사번, 
		EMP_NAME 이름, 
		SALARY AS "급여(원)",
		(SYSDATE - HIRE_DATE) "근무 일수" 
FROM EMPLOYEE e ;
		
-------------------------------------------

-- 리터럴 : 값 자체

-- DB에서의 리터럴 : 임의로 지정한 값을 기존 테이블에 존재하는 값 처럼 사용
--> 리터럴 표기법 : ''(홑따옴표)

SELECT EMP_NAME, SALARY, '원' 단위
FROM EMPLOYEE ;

--------------------------------------------

-- DISTINCT : 조회 시 컬럼에 포함된 중복 값을 한 번만 표시할 때 사용

-- * 주의사항 *
-- 1) DISTINCT 는 SELECT문에 딱 한번만 작성할 수 있다.
-- 2) DISTINCT는 SELECT문 가장 앞에 작성 되어야 한다. 

-- EMPLOYEE 테이블에 저장된 직원들이 속해있는 부서 코드 종류 조회
SELECT DISTINCT DEPT_CODE FROM EMPLOYEE e ;

--------------------------------------------
-- WHERE절 
--> 테이블에서 조건을 충족하는 값을 가진 행만 조회하고자 할 때 사용

-- 비교 연산자 : >, <, >=, <=, = (같다), != (같지 않다), <> (같지 않다)

-- EMPLOYEE 테이블에서 급여가 3백만원 초과인 직원의
-- 사번, 이름, 급여, 부서코드를 조회
/* 해석 순서 */

/*3*/SELECT EMP_ID, EMP_NAME, SALARY, DEPT_CODE 
/*1*/FROM EMPLOYEE 
/*2*/WHERE SALARY > 3000000;

-- EMPLOYEE 테이블에서
-- 부서코드가 'D9'인 직원의
-- 사번, 이름, 부서코드, 전화번호 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, PHONE 
FROM EMPLOYEE 
WHERE DEPT_CODE = 'D9';

-------------------------------------------
-- 논리 연산자(AND, OR)

-- EMPLOYEE 테이블에서 급여가 200만 이상이고
-- 부서코드가 'D6'인 직원의
-- 이름, 급여, 부서코드를 조회

SELECT EMP_NAME, SALARY, DEPT_CODE 
FROM EMPLOYEE e 
WHERE SALARY > 2000000 AND DEPT_CODE = 'D6';

-- EMPLOYEE 테이블에서 
-- 급여가 300만 이상, 500만 이하인 직원의
-- 사번, 이름, 급여 조회

SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE 
WHERE SALARY >= 3000000 
	AND SALARY <= 5000000;
	
-- EMPLOYEE 테이블에서
-- 부서코드가 'D6' 또는 'D9'인 사원의
-- 사번, 이름, 부서코드 조회

SELECT EMP_ID, EMP_NAME, DEPT_CODE 
FROM EMPLOYEE 
WHERE  DEPT_CODE = 'D6'
	OR DEPT_CODE = 'D9';
	
------------------------------------------

-- 컬럼명 BETWEEN A AND B : 컬럼 값이 A이상 B이하인 경우

-- EMPLOYEE 테이블에서 
-- 급여가 300만 이상, 500만 이하인 직원의
-- 사번, 이름, 급여 조회
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE 
WHERE SALARY BETWEEN 3000000 AND 5000000;

-- 컬럼명 NOT BETWEEN A AND B : 컬럼 값이 A이상 B이하가 아닌 경우
--							== 컬럼 값이 A미만, B초과인 경우

-- EMPLOYEE 테이블에서 
-- 급여가 300만 미만, 500만 초과인 직원의
-- 사번, 이름, 급여 조회
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE 
WHERE SALARY NOT BETWEEN 3000000 AND 5000000;

/* BETWEEN을 이용한 날짜 비교 */
-- EMPLOYEE 테이블에서
-- 입사일이 1990/01/1 ~ 1999/12/31인 (== 90년도 입사자)
-- 직원의 사번, 이름, 입사일 조회

SELECT EMP_ID, EMP_NAME, HIRE_DATE
FROM EMPLOYEE 
WHERE HIRE_DATE BETWEEN '1990/01/01' AND '1999/12/31';

-- '1990/01/01' 날짜를 문자열 형식으로 작성하게 되면
-- DB가 알아서 판단하여 날짜타입(DATE)으로 형변환을 진행함

-------------------------------------------------------
/* LIKE
 * 
 * - 비교하려는 값이 특정한 패턴을 만족 시키면 조회하는 연산자
 * 
 * [작성법]
 * WHERE 컬럼명 LIKE '패턴'
 * 
 * - LIKE 패턴(와일드카드) : '%' (포함), '_'(글자 수)
 * 
 * '%' (포함) 
 * - '%A' : 문자열이 A로 끝나는 모든 컬럼 값 
 * - 'A%' : 문자열이 A로 시작하는 모든 컬럼 값
 * - '%A%' : A가 포함된 문자열
 * 
 * '_' (글자 수)
 * - 'A_' : A 뒤에 아무거나 한 글자가 포함된 컬럼 값
 * - '___A' : A 앞에 아무거나 세 글자 (== 4 글자 문자열 이면서 A로 끝나야 함)
 * */

-- EMPLOYEE 테이블에서 성이 '전'씨인 사원의 사번, 이름 조회
SELECT EMP_ID, EMP_NAME
FROM EMPLOYEE 
WHERE EMP_NAME LIKE '전%';

-- EMPLOYEE 테이블에서 이름에 '하'가 포함된 사원의 사번, 이름 조회
SELECT EMP_ID, EMP_NAME
FROM EMPLOYEE 
WHERE EMP_NAME LIKE '%하%';

-- EMPLOYEE 테이블에서 전화번호가 010으로 시작하는 사원의 사번, 이름, 전화번호 조회
SELECT EMP_ID, EMP_NAME, PHONE
FROM EMPLOYEE 
WHERE PHONE LIKE '010%';

-- 010으로 시작하지 "않는" 사람들 조회
--> NOT LIKE (LIKE 결과 부정)
SELECT EMP_ID, EMP_NAME, PHONE
FROM EMPLOYEE 
WHERE PHONE NOT LIKE '010%';

-- EMPLOYEE 테이블에서
-- 이메일에 _ 앞글자가 세글자인 사원 사번,이름,이메일 조회
SELECT EMP_ID, EMP_NAME, EMAIL
FROM EMPLOYEE 
WHERE EMAIL LIKE '___%';

-- 문제점 : 와일드 카드 문자(_)와 패턴에 사용된 일반 문자(_)의 모양이 같아서 문제 발생
-- 해결 방법 : ESCAPE OPTION을 이용하여 일반 문자로 처리할 '_', '%' 앞에 아무 특수문자나 붙임
SELECT EMP_ID, EMP_NAME, EMAIL
FROM EMPLOYEE 
WHERE EMAIL LIKE '___$_%' ESCAPE '$';
